//////////////////////////////////////////////////////////////////////////
template<class T>
deque<T>::deque(const deque& other)
    : container(other.container)
{
}

//////////////////////////////////////////////////////////////////////////
template<class T>
deque<T>& deque<T>::operator=(const deque& rhs)
{
    if (this != &rhs)
    {
        container = rhs.container;
    }
    return *this;
}

//////////////////////////////////////////////////////////////////////////
template<class T>
bool deque<T>::is_empty() const
{
    return container.is_empty();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
size_t deque<T>::size() const
{
    return container.size();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
void deque<T>::push_front(const T& data)
{
    container.push_front(data);
}

//////////////////////////////////////////////////////////////////////////
template<class T>
void deque<T>::push_back(const T& data)
{
    container.push_back(data);
}

//////////////////////////////////////////////////////////////////////////
template<class T>
T deque<T>::pop_front()
{
    return container.pop_front();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
T deque<T>::pop_back()
{
    return container.pop_back();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
T& deque<T>::peek_front()
{
    return container.peek_front();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
const T& deque<T>::peek_front() const
{
    return container.peek_front();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
T& deque<T>::peek_back()
{
    return container.peek_back();
}

//////////////////////////////////////////////////////////////////////////
template<class T>
const T& deque<T>::peek_back() const
{
    return container.peek_back();
}